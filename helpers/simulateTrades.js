//PURPOSE: use the patternstats generated by discoverPatterns to evaluate trade strategies (by simulating trades)

const { loadHistoricalDataForSymbol } = require('./symbolData'),
  _ = require('lodash'),
  moment = require('moment'),
  { isNullOrUndefined } = require('./miscMethods'),
  PatternStats = require('../models/patternStats'),
  PatternStatsJobRun = require('../models/patternStatsJobRun');

/*
example config:

  const config = {
    min_upsideDownsideRatio_byBarX: null,
    min_avg_maxUpsidePercent_byBarX: null,
    max_avg_maxDownsidePercent_byBarX: null,
    min_avg_profitLossPercent_atBarX: null,
    min_percentProfitable_atBarX: { 1: 70, 5: 70, 10: 70 },
    min_percentProfitable_by_1_percent_atBarX: null,
    min_percentProfitable_by_2_percent_atBarX: null,
    min_percentProfitable_by_5_percent_atBarX: null,
    min_percentProfitable_by_10_percent_atBarX: null,
    max_avgScore: null,
    min_scoreCount: 10,
  };
*/

const cachedHistoricalData = {};

const runTradeSimulation = async (
  symbol,
  numberOfBars,
  maxPatternMatchingScore,
  significantBar,
  config
) => {
  const jobRuns = await PatternStatsJobRun.find({
    sourceSymbol: symbol,
    numberOfBars,
    maxPatternMatchingScore,
  });
  if (jobRuns.length === 0) {
    throw `No job runs found for the combination: { sourceSsymbol: ${symbol}, numberOfBars: ${numberOfBars}, maxPatternMatchingScore: ${maxPatternMatchingScore} }`;
  }
  if (jobRuns.length > 1) {
    throw 'should be unique per (symbol + numberOfBars + maxPatternMatchingScore). Make sure the job run "find" criteria is restrictive enough';
  }
  const jobRun = jobRuns[0];

  const candles = cachedHistoricalData[symbol]
    ? cachedHistoricalData[symbol]
    : await loadHistoricalDataForSymbol(symbol);
  cachedHistoricalData[symbol] = candles;

  //----------------------------
  const queryFilter = {
    jobRun: jobRun.id,
  };
  const addToQueryFilter = (
    configKey,
    patternStatFieldName,
    operator,
    useSignificantBar = true
  ) => {
    if (
      config[configKey] &&
      (!useSignificantBar || config[configKey][significantBar])
    ) {
      if (useSignificantBar) {
        queryFilter[`${patternStatFieldName}.${significantBar}`] = {
          [operator]: config[configKey][significantBar],
        };
      } else {
        queryFilter[patternStatFieldName] = {
          [operator]: config[configKey],
        };
      }
    }
  };

  addToQueryFilter(
    'min_percentProfitable_atBarX',
    'percentProfitable_atBarX',
    '$gte'
  );
  addToQueryFilter(
    'min_percentProfitable_by_1_percent_atBarX',
    'percentProfitable_by_1_percent_atBarX',
    '$gte'
  );
  addToQueryFilter(
    'min_percentProfitable_by_2_percent_atBarX',
    'percentProfitable_by_2_percent_atBarX',
    '$gte'
  );
  addToQueryFilter(
    'min_percentProfitable_by_5_percent_atBarX',
    'percentProfitable_by_5_percent_atBarX',
    '$gte'
  );
  addToQueryFilter(
    'min_percentProfitable_by_10_percent_atBarX',
    'percentProfitable_by_10_percent_atBarX',
    '$gte'
  );
  addToQueryFilter(
    'min_upsideDownsideRatio_byBarX',
    'upsideDownsideRatio_byBarX',
    '$gte'
  );
  addToQueryFilter(
    'min_avg_maxUpsidePercent_byBarX',
    'avg_maxUpsidePercent_byBarX',
    '$gte'
  );
  addToQueryFilter(
    'max_avg_maxDownsidePercent_byBarX',
    'avg_maxDownsidePercent_byBarX',
    '$lte'
  );
  addToQueryFilter(
    'min_avg_profitLossPercent_atBarX',
    'avg_profitLossPercent_atBarX',
    '$gte'
  );
  addToQueryFilter('min_scoreCount', 'scoreCount', '$gte');
  addToQueryFilter('max_avgScore', 'avgScore', '$lte', false);

  //----------------------------

  const patternStats = (
    await PatternStats.find(queryFilter).sort({
      sourceDate: 1,
    })
  ).filter(
    (ps) =>
      !isNullOrUndefined(ps.actualProfitLossPercent_atBarX[significantBar])
  );
  const listedProfitLossPercents = patternStats.map(
    (p) => p.actualProfitLossPercent_atBarX[significantBar]
  );

  const tradeCount = patternStats.length;
  const profitableCount = patternStats.filter(
    (p) => p.actualProfitLossPercent_atBarX[significantBar] > 0
  ).length;
  const avgProfitLossPercent =
    Math.round(
      10 *
        _.meanBy(
          patternStats,
          (p) => p.actualProfitLossPercent_atBarX[significantBar]
        )
    ) / 10;

  const percentProfitable =
    Math.round((1000 * profitableCount) / tradeCount) / 10;

  const daysEvaluatedCount = moment(
    candles[candles.length - 1].date,
    'YYYY-MM-DD'
  ).diff(moment(candles[0].date, 'YYYY-MM-DD'), 'days');
  const tradeCountPerYear =
    Math.round((10 * tradeCount) / (daysEvaluatedCount / 365.25)) / 10;

  const tradeResults = {
    avgProfitLossPercent,
    listedProfitLossPercents,
    percentProfitable,
    tradeCount,
    daysEvaluatedCount,
    tradeCountPerYear,
  };

  return tradeResults;
};
exports.runTradeSimulation = runTradeSimulation;
