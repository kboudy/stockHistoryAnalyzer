//PURPOSE: use the patternstats generated by discoverPatterns to evaluate trade strategies (by simulating trades)

const { loadHistoricalDataForSymbol } = require('./symbolData'),
  _ = require('lodash'),
  chalk = require('chalk'),
  moment = require('moment'),
  { isNullOrUndefined, isObject, isEmptyObject } = require('./commonMethods'),
  PatternStats = require('../models/patternStats'),
  PatternStatsJobRun = require('../models/patternStatsJobRun');

const runTradeSimulation = async (
  symbol,
  includeOtherSymbolsTargets,
  numberOfBars,
  ignoreMatchesAboveThisScore,
  significantBar,
  config,
  logToConsole
) => {
  let jobRuns = await PatternStatsJobRun.find({
    sourceSymbol: symbol,
    numberOfBars,
    ignoreMatchesAboveThisScore,
  });
  if (jobRuns.length === 0) {
    throw `No job runs found for the combination: { sourceSymbol: ${symbol}, numberOfBars: ${numberOfBars}, ignoreMatchesAboveThisScore: ${ignoreMatchesAboveThisScore} }`;
  }
  jobRuns = jobRuns.filter((jr) =>
    includeOtherSymbolsTargets
      ? jr.targetSymbols.length > 1
      : jr.targetSymbols.length === 1
  );
  if (jobRuns.length > 1) {
    console.log(jobRuns.length);
    throw 'should be unique per (symbol + numberOfBars + ignoreMatchesAboveThisScore + [includeOtherSymbolsTargets]). Make sure the job run "find" criteria is restrictive enough';
  }
  const jobRun = jobRuns[0];

  const candles = await loadHistoricalDataForSymbol(symbol);

  //----------------------------
  const queryFilter = {
    jobRun: jobRun.id,
  };
  const addToQueryFilter = (
    configKey,
    patternStatFieldName,
    operator,
    useSignificantBar = true
  ) => {
    if (
      isNullOrUndefined(config[configKey]) ||
      isEmptyObject(config[configKey])
    ) {
      return;
    }
    if (useSignificantBar) {
      // make sure config field is written in the {significantBar: value} format (as opposed to a literal)
      if (isObject(config[configKey])) {
        const firstKey = Object.keys(config[configKey])[0];
        queryFilter[`${patternStatFieldName}.${significantBar}`] = {
          [operator]: config[configKey][firstKey],
        };
      } else {
        queryFilter[`${patternStatFieldName}.${significantBar}`] = {
          [operator]: config[configKey],
        };
      }
    } else {
      queryFilter[patternStatFieldName] = {
        [operator]: config[configKey],
      };
    }
  };

  addToQueryFilter(
    'min_percentProfitable_atBarX',
    'percentProfitable_atBarX',
    '$gte'
  );
  addToQueryFilter(
    'min_percentProfitable_by_1_percent_atBarX',
    'percentProfitable_by_1_percent_atBarX',
    '$gte'
  );
  addToQueryFilter(
    'min_percentProfitable_by_2_percent_atBarX',
    'percentProfitable_by_2_percent_atBarX',
    '$gte'
  );
  addToQueryFilter(
    'min_percentProfitable_by_5_percent_atBarX',
    'percentProfitable_by_5_percent_atBarX',
    '$gte'
  );
  addToQueryFilter(
    'min_percentProfitable_by_10_percent_atBarX',
    'percentProfitable_by_10_percent_atBarX',
    '$gte'
  );
  addToQueryFilter(
    'min_upsideDownsideRatio_byBarX',
    'upsideDownsideRatio_byBarX',
    '$gte'
  );
  addToQueryFilter(
    'min_avg_maxUpsidePercent_byBarX',
    'avg_maxUpsidePercent_byBarX',
    '$gte'
  );
  addToQueryFilter(
    'max_avg_maxDownsidePercent_byBarX',
    'avg_maxDownsidePercent_byBarX',
    '$lte'
  );
  addToQueryFilter(
    'min_avg_profitLossPercent_atBarX',
    'avg_profitLossPercent_atBarX',
    '$gte'
  );
  addToQueryFilter('min_scoreCount', 'scoreCount', '$gte', false);
  addToQueryFilter('max_avgScore', 'avgScore', '$lte', false);

  if (logToConsole) {
    console.log(
      `queryFilter: ${chalk.blueBright(JSON.stringify(queryFilter))}`
    );
  }
  //----------------------------

  const patternStats = (
    await PatternStats.find(queryFilter).sort({
      sourceDate: 1,
    })
  ).filter(
    (ps) =>
      !isNullOrUndefined(ps.actualProfitLossPercent_atBarX) &&
      !isNullOrUndefined(ps.actualProfitLossPercent_atBarX[significantBar])
  );
  const listedActualProfitLossPercents = patternStats.map(
    (p) => p.actualProfitLossPercent_atBarX[significantBar]
  );
  const listedActualProfitLossSellDates = patternStats.map(
    (p) => p.actualProfitLossSellDate_atBarX[significantBar]
  );

  const tradeCount = patternStats.length;
  const profitableCount = patternStats.filter(
    (p) => p.actualProfitLossPercent_atBarX[significantBar] > 0
  ).length;
  const avgProfitLossPercent =
    Math.round(
      10 *
        _.meanBy(
          patternStats,
          (p) => p.actualProfitLossPercent_atBarX[significantBar]
        )
    ) / 10;

  const percentProfitable =
    Math.round((1000 * profitableCount) / tradeCount) / 10;

  const daysEvaluatedCount = moment(
    candles[candles.length - 1].date,
    'YYYY-MM-DD'
  ).diff(moment(candles[0].date, 'YYYY-MM-DD'), 'days');
  const tradeCountPerYear =
    Math.round((10 * tradeCount) / (daysEvaluatedCount / 365.25)) / 10;

  const tradeResults = {
    avgProfitLossPercent,
    listedProfitLossPercents: listedActualProfitLossPercents,
    listedProfitLossSellDates: listedActualProfitLossSellDates,
    percentProfitable,
    tradeCount,
    daysEvaluatedCount,
    tradeCountPerYear,
  };

  return tradeResults;
};
exports.runTradeSimulation = runTradeSimulation;
