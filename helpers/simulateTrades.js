//PURPOSE: use the patternstats generated by discoverPatterns to evaluate trade strategies (by simulating trades)

const { loadHistoricalDataForSymbol } = require('./symbolData'),
  _ = require('lodash'),
  moment = require('moment'),
  PatternStats = require('../models/patternStats'),
  PatternStatsJobRun = require('../models/patternStatsJobRun');

/*
example config:

  const config = {
    min_upsideDownsideRatio_byBarX: null,
    min_avg_maxUpsidePercent_byBarX: null,
    max_avg_maxDownsidePercent_byBarX: null,
    min_avg_profitLossPercent_atBarX: null,
    min_percentProfitable_atBarX: { 1: 70, 5: 70, 10: 70 },
    min_percentProfitable_by_1_percent_atBarX: null,
    min_percentProfitable_by_2_percent_atBarX: null,
    min_percentProfitable_by_5_percent_atBarX: null,
    min_percentProfitable_by_10_percent_atBarX: null,
    max_avgScore: null,
    min_scoreCount: 10,
  };
*/

const cachedHistoricalData = {};

const runTradeSimulation = async (
  symbols,
  numberOfBars,
  maxPatternMatchingScore,
  significantBars,
  config
) => {
  const tradeResults_perSymbol_perBar = {};

  for (const symbol of symbols) {
    const jobRuns = await PatternStatsJobRun.find({
      'sourcePriceInfo.symbol': symbol,
      numberOfBars,
      maxPatternMatchingScore,
    });
    if (jobRuns.length === 0) {
      throw `No job runs found for the combination: { sourcePriceInfo.symbol: ${symbol}, numberOfBars: ${numberOfBars}, maxPatternMatchingScore: ${maxPatternMatchingScore} }`;
    }
    if (jobRuns.length > 1) {
      throw 'should be unique per (symbol + numberOfBars + maxPatternMatchingScore). Make sure the job run "find" criteria is restrictive enough';
    }
    const jobRun = jobRuns[0];

    const candles = cachedHistoricalData[symbol]
      ? cachedHistoricalData[symbol]
      : await loadHistoricalDataForSymbol(symbol);
    cachedHistoricalData[symbol] = candles;

    const patternStats = _.orderBy(
      await PatternStats.find({
        jobRun: jobRun.id,
      }),
      (s) => s.sourceDate
    );
    const profitLossPercentSum_perBar = {};
    const profitLossCollection_perBar = {};
    const tradeCount_perBar = {};
    const profitableCount_perBar = {};
    for (const p of patternStats) {
      if (!config.min_scoreCount || p.scoreCount >= config.min_scoreCount) {
        const validationPairs = [
          {
            configVal: config.min_percentProfitable_atBarX,
            patternStatsVal: p.percentProfitable_atBarX,
            includesBar: true,
          },
          {
            configVal: config.min_percentProfitable_by_1_percent_atBarX,
            patternStatsVal: p.percentProfitable_by_1_percent_atBarX,
            includesBar: true,
          },
          {
            configVal: config.min_percentProfitable_by_2_percent_atBarX,
            patternStatsVal: p.percentProfitable_by_2_percent_atBarX,
            includesBar: true,
          },
          {
            configVal: config.min_percentProfitable_by_5_percent_atBarX,
            patternStatsVal: p.percentProfitable_by_5_percent_atBarX,
            includesBar: true,
          },
          {
            configVal: config.min_percentProfitable_by_10_percent_atBarX,
            patternStatsVal: p.percentProfitable_by_10_percent_atBarX,
            includesBar: true,
          },
          {
            configVal: config.min_upsideDownsideRatio_byBarX,
            patternStatsVal: p.upsideDownsideRatio_byBarX,
            includesBar: true,
          },
          {
            configVal: config.min_avg_maxUpsidePercent_byBarX,
            patternStatsVal: p.avg_maxUpsidePercent_byBarX,
            includesBar: true,
          },
          {
            configVal: config.max_avg_maxDownsidePercent_byBarX,
            patternStatsVal: p.avg_maxDownsidePercent_byBarX,
            isMax: true,
            includesBar: true,
          },
          {
            configVal: config.min_avg_profitLossPercent_atBarX,
            patternStatsVal: p.avg_profitLossPercent_atBarX,
            includesBar: true,
          },
          {
            configVal: config.max_avgScore,
            patternStatsVal: p.avgScore,
            isMax: true,
            includesBar: false,
          },
        ];
        for (const sb of significantBars) {
          let validationPassed = true;
          for (const vp of validationPairs) {
            if (vp.includesBar) {
              if (vp.configVal && vp.configVal[sb]) {
                if (vp.patternStatsVal[sb] !== 0 && !vp.patternStatsVal[sb]) {
                  // if the value is null/undefined and config is looking for a match, fail validation
                  validationPassed = false;
                  break;
                }
                if (
                  vp.isMax
                    ? vp.patternStatsVal[sb] > vp.configVal[sb]
                    : vp.patternStatsVal[sb] < vp.configVal[sb]
                ) {
                  validationPassed = false;
                  break;
                }
              }
            } else {
              if (vp.configVal) {
                if (vp.patternStatsVal !== 0 && !vp.patternStatsVal) {
                  // if the value is null/undefined and config is looking for a match, fail validation
                  validationPassed = false;
                  break;
                }
                if (
                  vp.isMax
                    ? vp.patternStatsVal > vp.configVal
                    : vp.patternStatsVal < vp.configVal
                ) {
                  validationPassed = false;
                  break;
                }
              }
            }
          }
          if (!validationPassed) {
            continue;
          }

          // all criteria passed - execute trade (if there's enough data)
          const patternStatCandleIndex = candles.indexOf(
            candles.filter((c) => c.date === p.sourceDate)[0]
          );
          const tradeCandleIndex = patternStatCandleIndex + numberOfBars;
          if (tradeCandleIndex + sb < candles.length) {
            const profitLossPercent =
              Math.round(
                (1000 *
                  (candles[tradeCandleIndex + sb].close -
                    candles[tradeCandleIndex].close)) /
                  candles[tradeCandleIndex].close
              ) / 10;
            if (!profitLossCollection_perBar[sb]) {
              profitLossCollection_perBar[sb] = [];
            }
            profitLossCollection_perBar[sb].push(profitLossPercent);
            if (!profitLossPercentSum_perBar[sb]) {
              profitLossPercentSum_perBar[sb] = 0;
            }
            profitLossPercentSum_perBar[sb] += profitLossPercent;
            if (!profitableCount_perBar[sb]) {
              profitableCount_perBar[sb] = 0;
            }
            if (profitLossPercent > 0) {
              profitableCount_perBar[sb]++;
            }

            if (!tradeCount_perBar[sb]) {
              tradeCount_perBar[sb] = 0;
            }
            tradeCount_perBar[sb]++;
          }
        }
      }
    }

    tradeResults_perSymbol_perBar[symbol] = {};
    for (const sb of significantBars) {
      const avgProfitLossPercent =
        Math.round(
          (10 * profitLossPercentSum_perBar[sb]) / tradeCount_perBar[sb]
        ) / 10;

      const profitablePercent =
        Math.round(
          (1000 * profitableCount_perBar[sb]) / tradeCount_perBar[sb]
        ) / 10;

      const tradeCount = tradeCount_perBar[sb];
      const daysEvaluatedCount = moment(
        candles[candles.length - 1].date,
        'YYYY-MM-DD'
      ).diff(moment(candles[0].date, 'YYYY-MM-DD'), 'days');
      const tradeCountPerYear =
        Math.round((10 * tradeCount) / (daysEvaluatedCount / 365.25)) / 10;
      const profitLossCollection = profitLossCollection_perBar[sb];
      tradeResults_perSymbol_perBar[symbol][sb] = {
        avgProfitLossPercent,
        profitablePercent,
        tradeCount,
        daysEvaluatedCount,
        tradeCountPerYear,
        profitLossCollection,
      };
    }
  }
  return tradeResults_perSymbol_perBar;
};
exports.runTradeSimulation = runTradeSimulation;
