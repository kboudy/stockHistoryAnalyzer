//PURPOSE: use the patternstats generated by discoverPatterns to evaluate trade strategies

const {
    getAvailableSymbolNames,
    loadHistoricalDataForSymbol,
  } = require('./helpers/symbolData'),
  _ = require('lodash'),
  { std } = require('mathjs'),
  constants = require('./helpers/constants'),
  { toTwoDecimals } = require('./helpers/miscMethods'),
  moment = require('moment'),
  mongoApi = require('./helpers/mongoApi'),
  mongoose = require('mongoose'),
  patternMatching = require('./patternMatching'),
  PatternStats = require('./models/patternStats'),
  PatternStatsJobRun = require('./models/patternStatsJobRun');

(async () => {
  await mongoApi.connectMongoose();

  const symbols = await getAvailableSymbolNames();

  const config = {
    symbolsToTrade: null,
    significantBarsToTrade: [1, 5, 10],
    min_upsideDownsideRatio_byBarX: null,
    min_avg_maxUpsidePercent_byBarX: null,
    max_avg_maxDownsidePercent_byBarX: null,
    min_avg_profitLossPercent_atBarX: null,
    min_percentProfitable_atBarX: { 1: 70, 5: 70, 10: 70 },
    min_percentProfitable_by_1_percent_atBarX: null,
    min_percentProfitable_by_2_percent_atBarX: null,
    min_percentProfitable_by_5_percent_atBarX: null,
    min_percentProfitable_by_10_percent_atBarX: null,
    min_avgScore: null,
    min_scoreCount: 10,
  };

  const symbolCount = config.symbolsToTrade
    ? config.symbolsToTrade.length
    : symbols.length;
  let loopNumber = 1;

  for (const symbol of symbols) {
    if (config.symbolsToTrade && !config.symbolsToTrade.includes(symbol)) {
      continue;
    }
    console.log(`${symbol} (${loopNumber}/${symbolCount})`);
    loopNumber++;
    const jobRuns = await PatternStatsJobRun.find({
      'sourcePriceInfo.symbol': symbol,
    });
    const candles = await loadHistoricalDataForSymbol(symbol);
    for (const j of jobRuns) {
      console.log(`  - jobRun numberOfBars:${j.numberOfBars} id:${j.id}`);
      const patternStats = _.orderBy(
        await PatternStats.find({
          jobRun: j.id,
        }),
        (s) => s.sourceDate
      );
      const profitLossPercentSum_perBar = {};
      const tradeCount_perBar = {};
      for (const p of patternStats) {
        if (!config.min_scoreCount || p.scoreCount >= config.min_scoreCount) {
          for (const sb of config.significantBarsToTrade) {
            if (
              config.min_percentProfitable_atBarX &&
              config.min_percentProfitable_atBarX[sb] &&
              p.percentProfitable_atBarX[sb] <
                config.min_percentProfitable_atBarX[sb]
            ) {
              continue;
            }
            // all criteria passed - execute trade (if there's enough data)
            const candleIndex = candles.indexOf(
              candles.filter((c) => c.date === p.sourceDate)[0]
            );
            const tradeCandleIndex = candleIndex + j.numberOfBars;
            if (tradeCandleIndex + sb < candles.length) {
              const profitLossPercent =
                Math.round(
                  (1000 *
                    (candles[tradeCandleIndex + sb].close -
                      candles[tradeCandleIndex].close)) /
                    candles[tradeCandleIndex].close
                ) / 10;
              if (!profitLossPercentSum_perBar[sb]) {
                profitLossPercentSum_perBar[sb] = 0;
              }
              profitLossPercentSum_perBar[sb] += profitLossPercent;
              if (!tradeCount_perBar[sb]) {
                tradeCount_perBar[sb] = 0;
              }
              tradeCount_perBar[sb]++;

              /*               console.log(
                `      + ${candles[tradeCandleIndex].date} - ${
                  candles[tradeCandleIndex + sb].date
                }: ${profitLossPercent}%`
              ); */
            }
          }
        }
      }
      //console.log('---------------------');
      for (const sb of config.significantBarsToTrade) {
        console.log(
          `  - ${sb} bars: trade count: ${tradeCount_perBar[sb]}, p/l%: ${(
            profitLossPercentSum_perBar[sb] / tradeCount_perBar[sb]
          ).toFixed(1)}`
        );
      }
    }
  }
  await mongoApi.disconnectMongoose();
})();
