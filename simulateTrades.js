//PURPOSE: use the patternstats generated by discoverPatterns to evaluate trade strategies

const {
    getAvailableSymbolNames,
    loadHistoricalDataForSymbol,
  } = require('./helpers/symbolData'),
  _ = require('lodash'),
  moment = require('moment'),
  constants = require('./helpers/constants'),
  mongoApi = require('./helpers/mongoApi'),
  PatternStats = require('./models/patternStats'),
  PatternStatsJobRun = require('./models/patternStatsJobRun');

/*
example config:

  const config = {
    symbolsToTrade: null,
    significantBarsToTrade: [1, 5, 10],
    min_upsideDownsideRatio_byBarX: null,
    min_avg_maxUpsidePercent_byBarX: null,
    max_avg_maxDownsidePercent_byBarX: null,
    min_avg_profitLossPercent_atBarX: null,
    min_percentProfitable_atBarX: { 1: 70, 5: 70, 10: 70 },
    min_percentProfitable_by_1_percent_atBarX: null,
    min_percentProfitable_by_2_percent_atBarX: null,
    min_percentProfitable_by_5_percent_atBarX: null,
    min_percentProfitable_by_10_percent_atBarX: null,
    min_avgScore: null,
    min_scoreCount: 10,
  };
*/

const cachedHistoricalData = {};
let cachedAllSymbols = null;

const runTradeSimulation = async (config) => {
  const tradeResults_perSymbol_perBar = {};
  const allSymbols = cachedAllSymbols
    ? cachedAllSymbols
    : await getAvailableSymbolNames();
  cachedAllSymbols = allSymbols;

  const symbolsToIterate = config.symbolsToTrade
    ? config.symbolsToTrade
    : allSymbols;

  for (const symbol of symbolsToIterate) {
    console.log(`${symbol}`);
    // for now, assuming 1 job run per symbol
    const jobRuns = await PatternStatsJobRun.find({
      'sourcePriceInfo.symbol': symbol,
    });

    const candles = cachedHistoricalData[symbol]
      ? cachedHistoricalData[symbol]
      : await loadHistoricalDataForSymbol(symbol);
    cachedHistoricalData[symbol] = candles;

    if (jobRuns.length > 1) {
      throw 'expected 1 job run per symbol';
    }
    for (const j of jobRuns) {
      console.log(`  - jobRun numberOfBars:${j.numberOfBars} id:${j.id}`);
      const patternStats = _.orderBy(
        await PatternStats.find({
          jobRun: j.id,
        }),
        (s) => s.sourceDate
      );
      const profitLossPercentSum_perBar = {};
      const profitLossCollection_perBar = {};
      const tradeCount_perBar = {};
      const profitableCount_perBar = {};
      for (const p of patternStats) {
        if (!config.min_scoreCount || p.scoreCount >= config.min_scoreCount) {
          const validationPairs = [
            {
              configVal: config.min_percentProfitable_atBarX,
              patternStatsVal: p.percentProfitable_atBarX,
            },
            {
              configVal: config.min_percentProfitable_by_1_percent_atBarX,
              patternStatsVal: p.percentProfitable_by_1_percent_atBarX,
            },
            {
              configVal: config.min_percentProfitable_by_2_percent_atBarX,
              patternStatsVal: p.percentProfitable_by_2_percent_atBarX,
            },
            {
              configVal: config.min_percentProfitable_by_5_percent_atBarX,
              patternStatsVal: p.percentProfitable_by_5_percent_atBarX,
            },
            {
              configVal: config.min_percentProfitable_by_10_percent_atBarX,
              patternStatsVal: p.percentProfitable_by_10_percent_atBarX,
            },
            {
              configVal: config.min_upsideDownsideRatio_byBarX,
              patternStatsVal: p.upsideDownsideRatio_byBarX,
            },
            {
              configVal: config.min_avg_maxUpsidePercent_byBarX,
              patternStatsVal: p.avg_maxUpsidePercent_byBarX,
            },
            {
              configVal: config.max_avg_maxDownsidePercent_byBarX,
              patternStatsVal: p.avg_maxDownsidePercent_byBarX,
              isMax: true,
            },
            {
              configVal: config.min_avg_profitLossPercent_atBarX,
              patternStatsVal: p.avg_profitLossPercent_atBarX,
            },
            {
              configVal: config.min_avgScore,
              patternStatsVal: p.avgScore,
            },
          ];
          for (const sb of config.significantBarsToTrade
            ? config.significantBarsToTrade
            : constants.significantBarsToTrade) {
            let validationPassed = true;
            for (const vp of validationPairs) {
              if (vp.configVal && vp.configVal[sb]) {
                if (vp.patternStatsVal[sb] !== 0 && !vp.patternStatsVal[sb]) {
                  // if the value is null/undefined and config is looking for a match, fail validation
                  validationPassed = false;
                  break;
                }
                if (
                  vp.isMax
                    ? vp.patternStatsVal[sb] > vp.configVal[sb]
                    : vp.patternStatsVal[sb] < vp.configVal[sb]
                ) {
                  validationPassed = false;
                  break;
                }
              }
            }
            if (!validationPassed) {
              continue;
            }

            // all criteria passed - execute trade (if there's enough data)
            const patternStatCandleIndex = candles.indexOf(
              candles.filter((c) => c.date === p.sourceDate)[0]
            );
            const tradeCandleIndex = patternStatCandleIndex + j.numberOfBars;
            if (tradeCandleIndex + sb < candles.length) {
              const profitLossPercent =
                Math.round(
                  (1000 *
                    (candles[tradeCandleIndex + sb].close -
                      candles[tradeCandleIndex].close)) /
                    candles[tradeCandleIndex].close
                ) / 10;
              if (!profitLossCollection_perBar[sb]) {
                profitLossCollection_perBar[sb] = [];
              }
              profitLossCollection_perBar[sb].push(profitLossPercent);
              if (!profitLossPercentSum_perBar[sb]) {
                profitLossPercentSum_perBar[sb] = 0;
              }
              profitLossPercentSum_perBar[sb] += profitLossPercent;
              if (!profitableCount_perBar[sb]) {
                profitableCount_perBar[sb] = 0;
              }
              if (profitLossPercent > 0) {
                profitableCount_perBar[sb]++;
              }

              if (!tradeCount_perBar[sb]) {
                tradeCount_perBar[sb] = 0;
              }
              tradeCount_perBar[sb]++;

              /*               console.log(
                  `      + ${candles[tradeCandleIndex].date} - ${
                    candles[tradeCandleIndex + sb].date
                  }: ${profitLossPercent}%`
                ); */
            }
          }
        }
      }

      tradeResults_perSymbol_perBar[symbol] = {};
      for (const sb of config.significantBarsToTrade) {
        const avgProfitLossPercent =
          Math.round(
            (10 * profitLossPercentSum_perBar[sb]) / tradeCount_perBar[sb]
          ) / 10;

        const profitablePercent =
          Math.round(
            (1000 * profitableCount_perBar[sb]) / tradeCount_perBar[sb]
          ) / 10;

        const tradeCount = tradeCount_perBar[sb];
        const daysEvaluatedCount = moment(
          candles[candles.length - 1].date,
          'YYYY-MM-DD'
        ).diff(moment(candles[0].date, 'YYYY-MM-DD'), 'days');
        const tradeCountPerYear =
          Math.round((10 * tradeCount) / (daysEvaluatedCount / 365.25)) / 10;
        const profitLossCollection = profitLossCollection_perBar[sb];
        tradeResults_perSymbol_perBar[symbol][sb] = {
          avgProfitLossPercent,
          profitablePercent,
          tradeCount,
          daysEvaluatedCount,
          tradeCountPerYear,
          profitLossCollection,
        };
      }
    }
  }
  return tradeResults_perSymbol_perBar;
};
exports.runTradeSimulation = runTradeSimulation;

(async () => {
  await mongoApi.connectMongoose();

  const results = await runTradeSimulation({
    symbolsToTrade: null,
    significantBarsToTrade: [1, 5, 10],
    min_upsideDownsideRatio_byBarX: null,
    min_avg_maxUpsidePercent_byBarX: null,
    max_avg_maxDownsidePercent_byBarX: null,
    min_avg_profitLossPercent_atBarX: null,
    min_percentProfitable_atBarX: { 1: 70, 5: 70, 10: 70 },
    min_percentProfitable_by_1_percent_atBarX: null,
    min_percentProfitable_by_2_percent_atBarX: null,
    min_percentProfitable_by_5_percent_atBarX: null,
    min_percentProfitable_by_10_percent_atBarX: null,
    min_avgScore: null,
    min_scoreCount: 10,
  });

  await mongoApi.disconnectMongoose();
})();
